/// <reference path="SyntaxTree/BlockBuilder.ts" />
/// <reference path="SyntaxTree/BlockType.ts" />
/// <reference path="SyntaxTree/Span.ts" />
/// <reference path="SyntaxTree/AcceptedCharacters.ts" />
/// <reference path="../ErrorSink.ts" />
/// <reference path="../Text/ITextDocument.ts" />
/// <reference path="../Text/TextDocumentReader.ts" />
/// <reference path="ParserBase.ts" />
/// <reference path="../RazorError.ts" />
/// <reference path="../Internals/DisposableAction.ts" />
/// <reference path="../Internals/IDisposable.ts" />
/// <reference path="../SourceLocation.ts" />
/// <reference path="../ParserResults.ts" />

namespace Razor.Parser
{
  import BlockBuilder = Razor.Parser.SyntaxTree.BlockBuilder;
  import BlockType = Razor.Parser.SyntaxTree.BlockType;
  import Span = Razor.Parser.SyntaxTree.Span;
  import AcceptedCharacters = Razor.Parser.SyntaxTree.AcceptedCharacters;
  import ErrorSink = Razor.ErrorSink;
  import ITextDocument = Razor.Text.ITextDocument;
  import TextDocumentReader = Razor.Text.TextDocumentReader;
  import ParserBase = Razor.Parser.ParserBase;
  import RazorError = Razor.RazorError;
  import DisposableAction = Razor.DisposableAction;
  import IDisposable = Razor.IDisposable;
  import SourceLocation = Razor.SourceLocation;
  import ParserResults = Razor.ParserResults;
  
  var EOF: number = -1;
  
  /**
   * Provides a context for parsing operations
   * @class
   */
  export class ParserContext
  {
    private _blockStack: BlockBuilder[] = [];
    private _errorSink: ErrorSink;
    private _source: TextDocumentReader;
    private _codeParser: ParserBase;
    private _markupParser: ParserBase;
    private _activeParser: ParserBase;
    private _lastSpan: Span;
    private _terminated: boolean = false;
    
    /**
     * Initialises a new instance of a parser context
     * @constructor
     * @param {ITextDocument} source - The source document
     * @param {ParserBase} codeParser - The code parser
     * @param {ParserBase} markupParser - The markup parser
     * @param {ParserBase} activeParser - The active parser
     * @param {ErrorSink} errorSink - The error sink
     */
    constructor(source: ITextDocument, codeParser: ParserBase, markupParser: ParserBase, activeParser: ParserBase, errorSink: ErrorSink)
    {
      this._source = new TextDocumentReader(source);
      this._codeParser = codeParser;
      this._markupParser = markupParser;
      this._activeParser = activeParser;
      this._errorSink = errorSink;
    }
    
    /**
     * Gets the active parser
     * @property
     * @readonly
     * @returns {ParserBase}
     */
    public get activeParser(): ParserBase
    {
      return this._activeParser;
    }
    
    /**
     * Gets the block stack
     * @property
     * @readonly
     * @returns {BlockBuilder[]}
     */
    public get blockStack(): BlockBuilder[]
    {
      return this._blockStack;
    }
    
    /**
     * Gets the code parser
     * @property
     * @readonly
     * @returns {ParserBase}
     */
    public get codeParser(): ParserBase
    {
      return this._codeParser;
    }
    
    /**
     * Gets the current block
     * @property
     * @readonly
     * @returns {BlockBuilder}
     */
    public get currentBlock(): BlockBuilder
    {
      if (this._blockStack.length > 0)
      {
        return this._blockStack[this._blockStack.length - 1];
      }
      return null;
    }
    
    /**
     * Gets the current character
     * @property
     * @readonly
     * @returns {string}
     */
    public get currentCharacter(): string
    {
      if (this._terminated)
      {
        return '\0';
      }
      
      var ch = this.source.peek();
      if (ch === EOF)
      {
        return '\0';
      }
      return <string>ch;
    }
    
    /**
     * Gets whether we are at the end of the input
     * @property
     * @readonly
     * @returns {boolean}
     */
    public get endOfFile(): boolean
    {
      return this._terminated || this.source.peek() === EOF;
    }
    
    /**
     * Gets the set of errors generated by the parsing operation.
     * @property
     * @readonly
     * @returns {RazorError[]}
     */
    public get errors(): RazorError[]
    {
      return this._errorSink.errors;
    }
    
    /**
     * Gets the last accepted characters
     * @property
     * @readonly
     * @returns {AcceptedCharacters}
     */
    public get lastAcceptedCharacters(): AcceptedCharacters
    {
      return AcceptedCharacters.None;
    }
    
    /**
     * Gets the last span
     * @property
     * @readonly
     * @returns {Span}
     */
    public get lastSpan(): Span
    {
      return this._lastSpan;
    }
    
    /**
     * Gets the markup parser
     * @property
     * @readonly
     * @returns {ParserBase}
     */
    public get markupParser(): ParserBase
    {
      return this._markupParser;
    }
    
    /**
     * Gets or sets whether null values generated whitespace and new lines
     * @property
     * @type {boolean}
     */
    public nullGeneratedWhitespaceAndNewLine: boolean;
    
    /**
     * Gets the source document reader
     * @property
     * @readonly
     * @returns {TextDocumentReader}
     */
    public get source(): TextDocumentReader
    {
      return this._source;
    }
    
    /**
     * Gets or sets whether whitespace is significant to anscentor blocks
     * @property
     * @type {boolean}
     */
    public whitespaceIsSignificantToAncestorBlock: boolean;
    
    /**
     * Adds the given span to the current block
     * @function
     * @param {Span} span - The span
     */
    public addSpan(span: Span): void
    {
      if (this._blockStack.length === 0)
      {
        throw "No current block";
      }
      
      this._blockStack[this._blockStack.length - 1].children.push(span);
      this._lastSpan = span;
    }
    
    /**
     * Completes the parser operation and returns the results
     * @function
     * @returns {ParserResults}
     */
    public completeParse(): ParserResults
    {
      if (this._blockStack.length === 0)
      {
        throw "Cannot complete tree - no root block";
      }
      if (this._blockStack.length !== 1)
      {
        throw "Cannot complete tree - outstanding blocks";
      }
      
      return new ParserResults(this._blockStack[this._blockStack.length -1].build(), [], this._errorSink);
    }
    
    /**
     * Ends the current block
     * @function
     */
    public endBlock(): void
    {
      if (this._blockStack.length === 0)
      {
        throw "End block called without matching start block";
      }
      if (this._blockStack.length > 1)
      {
        var block = this._blockStack.pop();
        this._blockStack[this._blockStack.length - 1].children.push(block.build());
      }
      else
      {
        // If we're at 1, terminate the parser.
        this._terminated = true;
      }
    }
    
    /**
     * Determines if any of the ancestor blocks of the current block is of the specified type
     * @function
     * @param {BlockType} type - The block type
     * @returns {boolean}
     */
    public isWithin(type: BlockType): boolean
    {
      for (var i = 0; i < this._blockStack.length; i++)
      {
        if (this._blockStack[i].type === type)
        {
          return true;
        }
      }
      return false;
    }
    
    /**
     * Tracks the given error, or creates a new error if providing a source location, message and length.
     * @function
     * @param {RazorError|SourceLocation} errorOrLocation - The error itself, or the location of the error
     * @param {string} [message] - The message
     * @param {number} [length] - The length of the erounous text
     */
    public onError(errorOrLocation: RazorError|SourceLocation, message?: string, length?: number): void
    {
      this._errorSink.onError(errorOrLocation, message, length);
    }
    
    /**
     * Starts a new block
     * @function
     * @param {BlockType} [blockType] - The block type
     * @returns {IDisposable}
     */
    public startBlock(blockType?: BlockType): IDisposable
    {
      var builder = new BlockBuilder();
      builder.type = blockType;
      
      return new DisposableAction(() => this.endBlock(), this);
    }
    
    /**
     * Switches the active parser
     * @function
     */
    public switchActiveParser(): void
    {
      if (this.activeParser === this.codeParser)
      {
        this._activeParser = this.markupParser;
      }
      else
      {
        this._activeParser = this.codeParser;
      }
    }
  }
}